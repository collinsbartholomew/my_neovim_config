--local M = {}
--
-- Health check function for the configuration
--function M.check()
--	local health = vim.health or require("health")
--	local start = health.start or health.report_start
--	local ok = health.ok or health.report_ok
--	local warn = health.warn or health.report_warn
--	local error = health.error or health.report_error
--
--	-- Start health check
--	start("Neovim Configuration Health Check")
--
--	-- Check Neovim version
--	local nvim_version = vim.version()
--	if nvim_version.minor >= 9 then
--		ok("Neovim version >= 0.9.0")
--	else
--		warn("Neovim version < 0.9.0. Some features may not work correctly")
--	end
--
--	-- Check required external dependencies
--	local required_executables = {
--		"git",
--		"gcc",
--		"npm",
--		"node",
--		"python3",
--		"cargo",
--		"go",
--	}
--
--	for _, exe in ipairs(required_executables) do
--		if vim.fn.executable(exe) == 1 then
--			ok(string.format("%s: installed", exe))
--		else
--			warn(string.format("%s: not found", exe))
--		end
--	end
--
--	-- Check treesitter parsers
--	local ts_ok, ts = pcall(require, "nvim-treesitter.parsers")
--	if ts_ok then
--		local parser_installed = ts.list_installed()
--		if #parser_installed > 0 then
--			ok(string.format("Treesitter parsers installed: %d", #parser_installed))
--		else
--			warn("No treesitter parsers installed")
--		end
--	else
--		error("Treesitter not properly installed")
--	end
--
--	-- Check LSP servers
--	local active_clients = vim.lsp.get_active_clients()
--	if #active_clients > 0 then
--		ok(string.format("Active LSP servers: %d", #active_clients))
--		for _, client in ipairs(active_clients) do
--			ok(string.format("LSP: %s", client.name))
--		end
--	else
--		warn("No active LSP servers")
--	end
--
--	-- Check plugin health
--	local plugins_to_check = {
--		"mason",
--		"telescope",
--		"treesitter",
--		--        "null-ls",
--		"which-key",
--	}
--
--	for _, plugin in ipairs(plugins_to_check) do
--		local plugin_health = string.format("health#%s#check", plugin)
--		if vim.fn.exists("*" .. plugin_health) == 1 then
--			vim.cmd("checkhealth " .. plugin)
--		end
--	end
--
--	-- Check core modules
--	for _, module in pairs(_G.modules.loaded) do
--		ok(string.format("Core module loaded: %s", module))
--	end
--
--	for name, err in pairs(_G.modules.failed) do
--		error(string.format("Failed to load module %s: %s", name, err))
--	end
--end
--
--function M.setup()
--    local null_ls = require("null-ls")
--    local formatting = null_ls.builtins.formatting
--    local diagnostics = null_ls.builtins.diagnostics
--    local code_actions = null_ls.builtins.code_actions
--
--    null_ls.setup({
--        debug = false,
--        sources = {
--            -- Lua
--            formatting.stylua,
--            diagnostics.luacheck.with({
--                extra_args = { "--globals", "vim" },
--            }),
--
--            -- JavaScript/TypeScript
--            diagnostics.eslint_d.with({
--                condition = function(utils)
--                    return utils.root_has_file({
--                        '.eslintrc.js',
--                        '.eslintrc.json',
--                        '.eslintrc.yaml',
--                        '.eslintrc.yml',
--                    })
--                end,
--            }),
--            code_actions.eslint_d,
--            formatting.prettier.with({
--                extra_args = { "--single-quote", "--jsx-single-quote" },
--            }),
--
--            -- General
--            diagnostics.trail_space,
--            diagnostics.todo_comments,
--        },
--        on_attach = function(client, bufnr)
--            if client.supports_method("textDocument/formatting") then
--                vim.api.nvim_create_autocmd("BufWritePre", {
--                    buffer = bufnr,
--                    callback = function()
--                        vim.lsp.buf.format({
--                            bufnr = bufnr,
--                            filter = function(c)
--                                return c.name == "null-ls"
--                            end
--                        })
--                    end,
--                })
--            end
--        end,
--    })
--end
--
--return M
